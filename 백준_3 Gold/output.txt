from queue import PriorityQueue
newq = PriorityQueue()

imsi = []
diction = {}
hap2 = ""
class HuffmanNode:

    def __init__(self, word, freq):
        self.word = word
        self.freq = freq
        self.parent = None
        
        self.left = None
        self.right = None
        self.encode = None
        self.encodenum = None

    def __lt__(self, other):
        return self.freq < other.freq
    def _eq_ (self, other):
        return self.freq == other.freq
    def _ne_ (self, other):
        return self.freq != other.freq
    def preorder(self):
        print(self.word, end = ":")
        print(self.freq, end = " ")
        if(self.left != None):
            self.left.preorder()
                
        if(self.right != None):
            self.right.preorder()
        
    def inorder(self):
        if(self.left != None):
            self.left.inorder()
        print(self.word, end = ":")
        print(self.freq, end = " ")
        if(self.right != None):
            self.right.inorder()
    

    def encodingnum(self):
        

        if(self.left != None):
            
            self.left.encode ="0"
            self.left.encodingnum()
                
        if(self.right != None):
            
            self.right.encode = "1"
            self.right.encodingnum()

    def encoding(self):
        global imsi
        global diction
        if(self.parent != None):
            imsi = ["1"]


        if(self.left != None):
            
            imsi.append(self.left.encode)
            self.left.encoding()
                
        if(self.right != None):
            
            imsi.append(self.right.encode)
            self.right.encoding()

        # if(self.word == "+"):
        #     self.encodenum = imsi

        if((self.word != "+") and (self.word != None)):
            print(self.encodenum)
            self.encodenum =  imsi
            print(self.encodenum)
            hap = ""
            for i in range (len(self.encodenum)):
                hap = hap + self.encodenum[i]

            diction[self.word] = hap
            imsi.pop()

    def decoding(self):
        global hap2
        rootnode = self
        for i in range (len(string2)):
            for s in (string2[i]):

                if s == "0":
                    # if self.left != None:
                        self = self.left
                if s == "1":
                    # if self.right != None:
                        self = self.right
                if (self.left == None) or (self.right == None):
                    hap2 = hap2 + self.word
                    self = rootnode
            hap2 += "/"

    # def finddepth(self):





            

def Hufmman (n , newq):
    for i in range(n-1):
        if( i < n-2):

            p = newq.get()[1]
            q = newq.get()[1]
            r = HuffmanNode('+' , p.freq + q.freq)
            r.left = p
            r.right = q

            newq.put((r.freq, r))
        else:
            p = newq.get()[1]
            q = newq.get()[1]
            r = HuffmanNode('+' , p.freq + q.freq)
            r.left = p
            r.right = q
            r.right.parent = 100 # 오른쪽 탐색 최상단 부모노드에게 100의 값을 준다.
            newq.put((r.freq, r))
    return newq.get()[1]


# dictionary = {}
letternum = int(input())

letter = []
letter = list(input().split())
frequency = []
frequency = list(map(int, input().split()))

stringnum1 = int(input())

string1 = []
for i in range (stringnum1):
    string1.append(input())

stringnum2 = int(input())

string2 = []
for i in range (stringnum2):
    string2.append(input())


for i in range (len(letter)):
    node = HuffmanNode(letter[i], frequency[i])
    newq.put((node.freq , node))

huf = Hufmman(len(letter) , newq)


huf.encodingnum()
huf.encoding()


huf.preorder()
print()
huf.inorder()
print()

# encoding하기
for i in range (len(string1)):
    for s in (string1[i]):
        print(diction.get(s), end = "")
    print()   

huf.decoding()
        
splithap2 = hap2.split("/")
for i in range (stringnum2):
    print(splithap2[i], end = "")
    print()

print(diction)

